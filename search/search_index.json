{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"activity01_ros2topics_nodes/","title":"\ud83d\udcda Ros2 Topics","text":"<p>In this assigment I created 2 differente nodes with 2 different topics.</p>"},{"location":"activity01_ros2topics_nodes/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: Ros2 Topics </li> <li>Author: Angel Ivan Dominguez Cruz </li> <li>Subject: Applied Robotics</li> <li>Date: 29/01/2026 </li> </ul>"},{"location":"activity01_ros2topics_nodes/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: Implement and understand the basics of communication in ROS 2 by creating two nodes that interact via a publisher-subscriber model. The first node listens to messages published by the second node and responds by publishing its own messages.</li> </ul>"},{"location":"activity01_ros2topics_nodes/#3-first-code-only-publisher","title":"3) First Code: Only Publisher","text":"<pre><code>import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n</code></pre> <ul> <li>Libraries: The code starts by importing the necessary libraries. It uses rclpy, which is the ROS 2 Python client, and Node from rclpy.node to create the ROS node. The String message type from example_interfaces.msg is imported to send and receive text messages.</li> </ul> <pre><code>class myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('MY_NODE_NAME')    #define the node's name\n        self.get_logger().info('Emma is gay is operational')    #confirmation message\n        self.counter = 0\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(String, 'Robot_speaking',10)#crear publisher\n</code></pre> <ul> <li>Class Node: In this section, the class myNode_function is defined, which inherits from Node. This means the class represents a ROS 2 node. Inside the function, the node is initialized with the name MY_NODE_NAME and a log message is printed to indicate that the node is active. Additionally, a counter variable is initialized and a timer is set to trigger every second, calling the print_callback function each time. The publisher is also created here to send messages of type String on the Robot_speaking topic.</li> </ul> <pre><code>def print_callback(self):\n    self.get_logger().info('Emma is gay')   #message that is going to be repeated on the timer\n    msg = String()\n    msg.data = 'Emma is gay says hello: %d' % self.counter\n    self.counter += 1\n    self.publishers_.publish(msg)\n</code></pre> <ul> <li>Callback to Publish Messages: The print_callback function is called every second because of the timer set earlier. This function logs a message indicating that the node is about to send a message. It creates a new String message and assigns a text value to it, which includes the current value of the counter. The counter is then incremented, and the message is published to the Robot_speaking topic.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    EmmaIsGayNode=myNode_function()\n    rclpy.spin(EmmaIsGayNode)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n</code></pre> <ul> <li>Main Function: In the main function, rclpy.init() is called to initialize the ROS 2 client. A new instance of the node, EmmaIsGayNode, is created from the myNode_function class. The rclpy.spin() method keeps the node running, processing events until it is manually stopped. Finally, rclpy.shutdown() is called to shut down the ROS 2 client when the node stops.</li> </ul> <pre><code>if __name__==\"__main__\":\n    main()\n</code></pre> <ul> <li> <p>Execution: The last block ensures that the main() function is executed when the script is run directly. If the script is imported as a module in another program, this section will not be executed.</p> </li> <li> <p>Full Code: <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n\nclass myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('MY_NODE_NAME')    #define the node's name\n        self.get_logger().info('Emma is gay is operational')    #confirmation message\n        self.counter = 0\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(String, 'Robot_speaking',10)#crear publisher\n\n    def print_callback(self):\n        self.get_logger().info('Emma is gay')   #message that is goning to be repeated on the timer\n        msg = String()\n        msg.data = 'Emma is gay says hello: %d' % self.counter\n        self.counter +=1\n        self.publishers_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    EmmaIsGayNode=myNode_function()\n    rclpy.spin(EmmaIsGayNode)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n\nif __name__==\"__main__\":\n    main()\n</code></pre></p> </li> </ul>"},{"location":"activity01_ros2topics_nodes/#4-second-code-publisher-and-subscriber","title":"4) Second Code: Publisher and Subscriber","text":"<pre><code>import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n</code></pre> <ul> <li>Libraries: The code starts by importing the necessary libraries. It uses rclpy, which is the ROS 2 Python client, and Node from rclpy.node to create the ROS node. The String message type from example_interfaces.msg is imported to send and receive text messages.</li> </ul> <pre><code>class myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('c3po_node')    #define the node's name\n        self.suscriber_ = self.create_subscription(\n            String,'Robot_speaking',self.listener_callback,10) #create subscriber and link to the callback function\n        self.get_logger().info('c3po is operational')    #confirmation message\n        self.counter = 0\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(String, 'c3po_speaking',10)#crear publisher\n</code></pre> <ul> <li>Class Node: In this section, the class myNode_function is defined, which inherits from Node. This means the class represents a ROS 2 node. The node is initialized with the name c3po_node. Inside the function, a subscriber is created to lsiten to the messages on the \"Robot_speaking\" topic, with the listener_callback method handling incoming messages. A log message is printed to indicate that the node is active and also initializes a counter, creates a timer that triggers the print_callback function every second, and sets up a publisher to send messages to the c3po_speaking topic.</li> </ul> <pre><code>def listener_callback(self, msg: String):\n    self.get_logger().info(f'I heard: \"{msg.data}\"')\n</code></pre> <ul> <li>Subscriber Callback Function: The listener_callback function is called whenever a message is received on the Robot_speaking topic. The function logs the content of the received message, displaying it in the format \"I heard: message_data\". This allows the node to process and respond to the incoming messages.</li> </ul> <pre><code>def print_callback(self):\n    self.get_logger().info('c3po is sending a message')   #message that is going to be repeated on the timer\n    msg = String()\n    msg.data = 'c3po says hello: %d' % self.counter\n    self.counter +=1\n    self.publishers_.publish(msg)\n</code></pre> <ul> <li>Callback to Publish Messages: The print_callback function is called every second because of the timer set earlier. A new String message is created, and the message content is formatted to include the current value of the counter (incremented every second). Finally, the message is published to the c3po_speaking topic using the publisher.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    c3po=myNode_function()\n    rclpy.spin(c3po)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n</code></pre> <ul> <li>Main Function: In the main function, rclpy.init() is called to initialize the ROS 2 client. A new instance of the node, EmmaIsGayNode, is created from the myNode_function class. The rclpy.spin() method keeps the node running, processing events until it is manually stopped. Finally, rclpy.shutdown() is called to shut down the ROS 2 client when the node stops.</li> </ul> <pre><code>if __name__==\"__main__\":\n    main()\n</code></pre> <ul> <li> <p>Execution: The last block ensures that the main() function is executed when the script is run directly. If the script is imported as a module in another program, this section will not be executed.</p> </li> <li> <p>Full Code: <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import String\n\nclass myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('c3po_node')    #define the node's name\n        self.suscriber_ = self.create_subscription(\n            String,'Robot_speaking',self.listener_callback,10) #create subscriber and link to the callback function\n        self.get_logger().info('c3po is operational')    #confirmation message\n        self.counter = 0\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(String, 'c3po_speaking',10)#crear publisher\n\n    def listener_callback(self, msg: String):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n\n    def print_callback(self):\n        self.get_logger().info('c3po is sending a message')   #message that is goning to be repeated on the timer\n        msg = String()\n        msg.data = 'c3po says hello: %d' % self.counter\n        self.counter +=1\n        self.publishers_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    c3po=myNode_function()\n    rclpy.spin(c3po)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n\nif __name__==\"__main__\":\n    main()\n</code></pre></p> </li> </ul>"},{"location":"activity01_ros2topics_nodes/#5-results","title":"5) Results","text":""},{"location":"activity01_ros2topics_nodes/#6-conclusions","title":"6) Conclusions","text":"<ul> <li>General: This code demonstrates the fundamental concepts of communication in ROS 2 using a publisher-subscriber model. The c3po_node subscribes to messages from the Robot_speaking topic and logs any incoming data, while also publishing its own messages every second to the c3po_speaking topic, with a counter that increments with each message. The diagram of thise excercise is this one:</li> </ul>"},{"location":"activity02_ros2services/","title":"\ud83d\udcda Ros2 Topics","text":"<p>In this assigment I created 2 differente nodes and a service with 2 different topics.</p>"},{"location":"activity02_ros2services/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: Ros2 Services </li> <li>Author: Angel Ivan Dominguez Cruz </li> <li>Subject: Applied Robotics</li> <li>Date: 17/02/2026 </li> </ul>"},{"location":"activity02_ros2services/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: Implement and understand the basics of communication in ROS 2 by creating two nodes that interact via a publisher-subscriber model and a service that controls one node.</li> </ul>"},{"location":"activity02_ros2services/#3-first-code-only-publisher","title":"3) First Code: Only Publisher","text":"<pre><code>import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n</code></pre> <ul> <li>Libraries: The code starts by importing the necessary libraries. It uses rclpy, which is the ROS 2 Python client, and Node from rclpy.node to create the ROS node. The String message type from example_interfaces.msg is imported to send and receive text messages.</li> </ul> <pre><code>class myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('Emma_Is_Gay')    #define the node's name\n        self.get_logger().info('Emma is gay is operational')    #confirmation message\n        self.num = 1\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(Int64, 'Robot_speaking',10)#crear publisher\n</code></pre> <ul> <li>Class Node: In this section, the class myNode_function is defined, which inherits from Node. This means the class represents a ROS2 node. Inside the function, the node is initialized with the name Emma_Is_Gay and a log message is printed to indicate that the node is active. A variable self.num is initialized to 1. Finally, it sets up a timer to trigger a callback function every 1.0 seconds and creates a publisher to send Int64 messages to the \"Robot_speaking\" topic with a queue size of 10.</li> </ul> <pre><code>    def print_callback(self):\n        self.get_logger().info('Emma is gay')   #message that is goning to be repeated on the timer\n        msg = Int64()\n        msg.data = self.num\n        self.publishers_.publish(msg)\n</code></pre> <ul> <li>Callback to Publish Messages: The print_callback function is executed every second by the timer created in the previous step. First, it logs the message \"Emma is gay\" to the console. Then, it creates a new Int64 message object, assigns the value of self.num (which is 1) to the message's data field, and publishes this message to the 'Robot_speaking' topic.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    EmmaIsGayNode=myNode_function()\n    rclpy.spin(EmmaIsGayNode)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n\nif __name__==\"__main__\":\n    main()\n</code></pre> <ul> <li> <p>Main Execution: The main function initializes the ROS2 communication (rclpy.init), creates an instance of the myNode_function class, and uses rclpy.spin to keep the node running and listening for callbacks until the program is manually stopped. Finally, it shuts down the ROS 2 client library cleanly.</p> </li> <li> <p>Full Code: <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\n\nclass myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('Emma_Is_Gay')    #define the node's name\n        self.get_logger().info('Emma is gay is operational')    #confirmation message\n        self.num = 1\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(Int64, 'Robot_speaking',10)#crear publisher\n\n    def print_callback(self):\n        self.get_logger().info('Emma is gay')   #message that is goning to be repeated on the timer\n        msg = Int64()\n        msg.data = self.num\n        self.publishers_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    EmmaIsGayNode=myNode_function()\n    rclpy.spin(EmmaIsGayNode)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n\nif __name__==\"__main__\":\n    main()\n</code></pre></p> </li> </ul>"},{"location":"activity02_ros2services/#4-second-code-publisher-subscriber-and-server","title":"4) Second Code: Publisher, Subscriber and Server","text":"<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\nfrom example_interfaces.srv import SetBool \n</code></pre> <ul> <li>Libraries: The code starts by importing the necessary libraries. It imports the standard rclpy library and the Node class. It imports two different interface types: Int64 for messages (topics) and SetBool (True/False) for the service (server/client communication).</li> </ul> <pre><code>class myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('c3po_node')    #define the node's name\n\n        self.acumulado=0\n\n        self.suscriber_ = self.create_subscription(\n            Int64,'Robot_speaking',self.listener_callback,10) #create subscriber and link to the callback function\n\n        self.server_ = self.create_service(\n            SetBool, #Type of the service\n            'reset_counter', #Service name\n            self.callback_reset_counter\n        )\n        self.get_logger().info('c3po is operational')    #confirmation message\n        self.counter = 0\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(Int64, 'c3po_speaking',10)#crear publisher\n</code></pre> <ul> <li>Node Initialization: In this section, the class myNode_function is defined. Inside \"init\", the node is named \"c3po_node\". It initializes an accumulator variable (self.acumulado) to 0. It sets up three main communication channels: The subscriber that listens to the \"Robot_speaking\" topic expecting an Int64 message, the server created with the name \"reset_counter\" using a SetBool type and a publisher that is prepared to send an Int64 message to the \"c3po_speaking\" topic.</li> </ul> <pre><code>    def callback_reset_counter(self, request, response): #Function that will be called when someone calls the service\n        if request.data == True: #If petition 'data: true'\n            self.acumulado = 0     # Reset counter.\n            self.get_logger().info('Resetting counter to 0.')\n\n            response.success = True # We fill the response message\n            response.message = \"Counter has been reseted.\" # We fill the response message (appears on the client)\n        else:\n            self.get_logger().info('Request ignored.')\n            response.success = False\n            response.message = \"Counter was NOT reset\"\n\n        return response\n</code></pre> <ul> <li>Service Callback: This function is triggered whenever another node calls the \"reset_counter\" service. It checks the request data (a boolean). If True, it resets self.acumulado to 0 and returns a success message. If False, it ignores the request and returns a failure message. This allows external control over the node's internal state.</li> </ul> <pre><code>    def listener_callback(self, msg: Int64):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n        recibido = msg.data #info from the first node\n        self.acumulado += recibido\n        self.get_logger().info(f'Acumulado: \"{self.acumulado}\"')\n</code></pre> <ul> <li>Subscriber Callback: The listener_callback function runs every time a message is received on the \"Robot_speaking\" topic. It logs the incoming data, adds the received integer value to the self.acumulado variable, and logs the new total.</li> </ul> <pre><code>    def print_callback(self):\n        self.get_logger().info('c3po is sending a message')   #message that is goning to be repeated on the timer\n        msg = Int64()\n        msg.data = self.counter\n        self.counter +=1\n        self.publishers_.publish(msg)\n</code></pre> <ul> <li>Publisher Callback: The print_callback runs every second (driven by the timer). It creates a new Int64 message, populates it with the current value of self.counter, and publishes it to 'c3po_speaking'. After publishing, it increments self.counter by 1.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    c3po=myNode_function()\n    rclpy.spin(c3po)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n\nif __name__==\"__main__\":\n    main()\n</code></pre> <ul> <li> <p>Main Execution: The main function initializes ROS2, creates the c3po_node object, and spins it to keep it active. This ensures the node stays alive to process service requests, subscriptions, and timer callbacks until the user stops the program.</p> </li> <li> <p>Full Code: <pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.msg import Int64\nfrom example_interfaces.srv import SetBool \n\n\nclass myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('c3po_node')    #define the node's name\n\n        self.acumulado=0\n\n        self.suscriber_ = self.create_subscription(\n            Int64,'Robot_speaking',self.listener_callback,10) #create subscriber and link to the callback function\n\n        self.server_ = self.create_service(\n            SetBool, #Type of the service\n            'reset_counter', #Service name\n            self.callback_reset_counter\n        )\n        self.get_logger().info('c3po is operational')    #confirmation message\n        self.counter = 0\n        self.create_timer(1.0, self.print_callback) #each second timer\n        self.publishers_= self.create_publisher(Int64, 'c3po_speaking',10)#crear publisher\n\n    def callback_reset_counter(self, request, response): #Function that will be called when someone calls the service\n        if request.data == True: #If petition 'data: true'\n            self.acumulado = 0     # Reset counter.\n            self.get_logger().info('Resetting counter to 0.')\n\n            response.success = True # We fill the response message\n            response.message = \"Counter has been reseted.\" # We fill the response message (appears on the client)\n        else:\n            self.get_logger().info('Request ignored.')\n            response.success = False\n            response.message = \"Counter was NOT reset\"\n\n        return response\n\n    def listener_callback(self, msg: Int64):\n        self.get_logger().info(f'I heard: \"{msg.data}\"')\n        recibido = msg.data #info from the first node\n        self.acumulado += recibido\n        self.get_logger().info(f'Acumulado: \"{self.acumulado}\"')\n\n    def print_callback(self):\n        self.get_logger().info('c3po is sending a message')   #message that is goning to be repeated on the timer\n        msg = Int64()\n        msg.data = self.counter\n        self.counter +=1\n        self.publishers_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    c3po=myNode_function()\n    rclpy.spin(c3po)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n\nif __name__==\"__main__\":\n    main()\n</code></pre></p> </li> </ul>"},{"location":"activity02_ros2services/#5-results","title":"5) Results","text":""},{"location":"activity02_ros2services/#6-conclusions","title":"6) Conclusions","text":"<ul> <li>General: This code demonstrates a ROS2 communication system involving two nodes interacting through multiple methods. The first node (Emma_Is_Gay) acts as a publisher, broadcasting integer data to the Robot_speaking topic every second. The second node (c3po_node) acts as a subscriber, listening to that topic and accumulating the received values, while simultaneously publishing its own counter to a different topic. Additionally, the second node implements a service server (reset_counter), allowing an external user or node to reset its internal accumulation variable to zero on demand. The diagram of thise excercise is this one:</li> </ul>"},{"location":"activity03_ros2custom_service/","title":"\ud83d\udcda Ros2 Custom Services","text":"<p>In this assignment, I created a custom service interface and two nodes (Battery and LED Panel) that interact as a client-server.</p>"},{"location":"activity03_ros2custom_service/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: Ros2 Custom Services (Battery &amp; LED)</li> <li>Author: Angel Ivan Dominguez Cruz</li> <li>Subject: Applied Robotics</li> <li>Date: 19/02/2026</li> </ul>"},{"location":"activity03_ros2custom_service/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: Understand how to create custom service definitions in ROS 2 and implement a system where a Client node (Battery) controls a Server node (LED Panel).</li> </ul>"},{"location":"activity03_ros2custom_service/#3-previous-step-creating-the-service-interface","title":"3) Previous Step: Creating the Service Interface","text":"<p>Before writing Python code, we needed to create a \"common language\" so the nodes could understand each other.</p> <ol> <li>New Package: We created a package called <code>my_robot_interfaces</code> to hold the definitions.</li> <li>The .srv File: We created a file named <code>SetLed.srv</code> with this structure:<ul> <li>Request: <code>int64 led_number</code> and <code>bool state</code>.</li> <li>Response: <code>bool success</code>.</li> </ul> </li> <li>Compilation: We modified <code>CMakeLists.txt</code> and <code>package.xml</code> to generate the code. Finally, we compiled it using <code>colcon build</code>.</li> </ol> <p>Now, both nodes can import <code>SetLed</code> to communicate.</p>"},{"location":"activity03_ros2custom_service/#4-first-code-led-panel-the-server","title":"4) First Code: LED Panel (The Server)","text":"<pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_interfaces.srv import SetLed\nfrom std_msgs.msg import Int64MultiArray\n</code></pre> <ul> <li>Libraries: The code starts by importing the necessary libraries. It imports rclpy, Node, the custom service SetLed (to receive orders) and the message Int64MultiArray to publish the list of LED states.</li> </ul> <pre><code>class LedPanelNode(Node):\n    def __init__(self):\n        super().__init__(\"led_panel\")\n        self.led_states_ = [0, 0, 0] \n        self.publisher_ = self.create_publisher(Int64MultiArray, \"led_panel_state\", 10)\n        self.timer_ = self.create_timer(1.0, self.publish_led_states)\n\n        self.server_ = self.create_service(SetLed, \"set_led\", self.callback_set_led)\n\n        self.get_logger().info(\"LED panel initialized\")\n</code></pre> <ul> <li>Class LedPanelNode: In this section, the node class is defined. The node is named \"led_panel\". It initializes a list [0, 0, 0] representing the 3 LEDs off. It creates a publisher to broadcast this status every second to the \"led_panel_state\" topic. Finally, it creates a Service Server named \"set_led\" that uses the SetLed type to wait for requests.</li> </ul> <pre><code>    def publish_led_states(self):\n        msg = Int64MultiArray()\n        msg.data = self.led_states_ \n        self.publisher_.publish(msg)\n</code></pre> <ul> <li>Publish Callback: This function runs every second controlled by the timer. It creates an Int64MultiArray message, assigns the current list of LEDs to it, and publishes it.</li> </ul> <pre><code>    def callback_set_led(self, request, response):\n        # request.led_number: LED number (1, 2 or 3)\n        # request.state: True (on) o False (off)\n\n        led_index = request.led_number - 1 #for the index\n\n        if 0 &lt;= led_index &lt; len(self.led_states_):\n            self.led_states_[led_index] = 1 if request.state else 0\n            response.success = True\n            self.get_logger().info(f\"LED {request.led_number} changing to {request.state}\")\n        else:\n            response.success = False\n            self.get_logger().error(\"Invalid number of LED\")\n\n        return response\n</code></pre> <ul> <li>Service Logic: This is the main logic of the server. When the Battery node sends a request, this function converts the LED number to an index. It checks if the LED number is valid (1, 2, or 3). If it is valid, it updates the internal list (1 for True, 0 for False) and sends a \"Success\" response. If invalid, it sends a failure response.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    node = LedPanelNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ul> <li> <p>Main Execution: The main function initializes the ROS2 communication (rclpy.init), creates an instance of the class, and uses rclpy.spin to keep the node running and listening for callbacks until the program is manually stopped. Finally, it shuts down the ROS 2 client library cleanly.</p> </li> <li> <p>Full Code: <pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_interfaces.srv import SetLed\nfrom std_msgs.msg import Int64MultiArray\n\nclass LedPanelNode(Node):\n    def __init__(self):\n        super().__init__(\"led_panel\")\n        self.led_states_ = [0, 0, 0] \n        self.publisher_ = self.create_publisher(Int64MultiArray, \"led_panel_state\", 10)\n        self.timer_ = self.create_timer(1.0, self.publish_led_states)\n\n        self.server_ = self.create_service(SetLed, \"set_led\", self.callback_set_led)\n\n        self.get_logger().info(\"Panel LED iniciado (Esperando \u00f3rdenes...)\")\n\n    def publish_led_states(self):\n        msg = Int64MultiArray()\n        msg.data = self.led_states_\n        self.publisher_.publish(msg)\n\n    def callback_set_led(self, request, response):\n        led_index = request.led_number - 1\n\n        if 0 &lt;= led_index &lt; len(self.led_states_):\n            self.led_states_[led_index] = 1 if request.state else 0\n            response.success = True\n            self.get_logger().info(f\"LED {request.led_number} cambiado a {request.state}\")\n        else:\n            response.success = False\n            self.get_logger().error(\"N\u00famero de LED inv\u00e1lido\")\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = LedPanelNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> </li> </ul>"},{"location":"activity03_ros2custom_service/#5-second-code-battery-node","title":"5) Second Code: Battery Node","text":"<pre><code>#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_interfaces.srv import SetLed\n</code></pre> <ul> <li>Libraries: We import rclpy, Node, and the same custom service SetLed. This time, we use the service definition to send requests (as a client).</li> </ul> <pre><code>class BatteryNode(Node):\n    def __init__(self):\n        super().__init__(\"battery_node\")\n        self.battery_full = True #Starting with a full battery\n        self.counter = 0\n        self.create_timer(1.0, self.check_battery)#1 second timer\n        self.get_logger().info(\"Bater\u00eda iniciada.\")\n</code></pre> <ul> <li>Node Initialization: The node starts with a \"full\" battery status and a counter variable at 0. It creates a timer that triggers the check_battery function every second to simulate the battery life cycle.</li> </ul> <pre><code>    def check_battery(self):\n        self.counter += 1\n\n        if self.battery_full:\n            if self.counter &gt;= 4:#it enters after 4 seconds of being full\n                self.get_logger().warn(\"Empty Battery!\")\n                self.battery_full = False \n                self.counter = 0 \n                self.call_led_service(3, True)#turn on LED 3 when battery is empty\n        else:\n            if self.counter &gt;= 6:\n                self.get_logger().info(\"Full Battery!\")\n                self.battery_full = True\n                self.counter = 0\n                self.call_led_service(3, False)#turn off LED 3 when battery is full\n</code></pre> <ul> <li>Battery Logic: This function simulates the battery draining. It increments a counter every second. After 4 seconds, if the battery was full, it sets it to empty and calls the service to Turn On LED 3. After 6 seconds, if the battery was empty, it sets it to full and calls the service to Turn Off LED 3.</li> </ul> <pre><code>    def call_led_service(self, led_number, state):\n        client = self.create_client(SetLed, \"set_led\")\n\n        while not client.wait_for_service(1.0):\n            self.get_logger().warn(\"Waiting service...\")\n\n        request = SetLed.Request() #request object for the service (led_number and state)\n        request.led_number = led_number\n        request.state = state\n\n        client.call_async(request)\n</code></pre> <ul> <li>Service Call: This is where the client communicates with the server. It creates a client for the \"set_led\" service and waits until the LED Panel service is available. It creates a \"request object\" filling in the led_number (3) and the state (True/False). It sends the request asynchronously (call_async) so the battery timer keeps working without freezing while waiting for a response.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    node = BatteryNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ul> <li> <p>Main Execution: The main function initializes ROS2, creates node object, and spins it to keep it active. This ensures the node stays alive to process service requests, subscriptions, and timer callbacks until the user stops the program.</p> </li> <li> <p>Full Code: <pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_interfaces.srv import SetLed\n\nclass BatteryNode(Node):\n    def __init__(self):\n        super().__init__(\"battery_node\")\n        self.battery_full = True #Starting with a full battery\n        self.counter = 0\n        self.create_timer(1.0, self.check_battery)#1 second timer\n        self.get_logger().info(\"Bater\u00eda iniciada.\")\n\n    def check_battery(self):\n        self.counter += 1\n\n        if self.battery_full:\n            if self.counter &gt;= 4:#it enters after 4 seconds of being full\n                self.get_logger().warn(\"Empty Battery!\")\n                self.battery_full = False \n                self.counter = 0 \n                self.call_led_service(3, True)#turn on LED 3 when battery is empty\n        else:\n            if self.counter &gt;= 6:\n                self.get_logger().info(\"Full Battery!\")\n                self.battery_full = True\n                self.counter = 0\n                self.call_led_service(3, False)#turn off LED 3 when battery is full\n\n    def call_led_service(self, led_number, state):\n        client = self.create_client(SetLed, \"set_led\")\n\n        while not client.wait_for_service(1.0):\n            self.get_logger().warn(\"Waiting service...\")\n\n        request = SetLed.Request() #request object for the service (led_number and state)\n        request.led_number = led_number\n        request.state = state\n\n        client.call_async(request)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = BatteryNode()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre></p> </li> </ul>"},{"location":"activity03_ros2custom_service/#6-results","title":"6) Results","text":""},{"location":"activity03_ros2custom_service/#7-conclusions","title":"7) Conclusions","text":"<ul> <li>General: This exercise demonstrated how to create a custom communication interface using .srv files. We successfully implemented a Server (LED Panel) that listens for commands and publishes its status, and a Client (Battery) that makes decisions based on time and sends orders to the server. The Client uses asynchronous calls to ensure the timing logic isn't interrupted while waiting for the server.</li> </ul>"},{"location":"activity04_ros2turtlesim/","title":"\ud83d\udcda Ros2 Turtlesim Catch Them All","text":"<p>In this assignment, I created a robotic ecosystem using ROS 2. It features a \"Spawner\" node that generates turtles randomly and a \"Controller\" node with PID Controller to autonomously hunt them.</p>"},{"location":"activity04_ros2turtlesim/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: ROS 2 Turtlesim Catch Them All</li> <li>Author: Angel Ivan Dominguez Cruz</li> <li>Subject: Applied Robotics</li> <li>Date: 24/02/2026</li> </ul>"},{"location":"activity04_ros2turtlesim/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: Understand how to integrate multiple ROS 2 concepts simultaneously: custom messages, custom services, dynamic parameters, publishers, subscribers, clients, and servers.</li> </ul>"},{"location":"activity04_ros2turtlesim/#3-previous-step-creating-the-service-interface","title":"3) Previous Step: Creating the Service Interface","text":"<p>Before writing the node logic, we needed to create a custom communication bridge so the Spawner and the Controller could share information about the alive turtles and the catching events.</p> <p>Inside the my_robot_interfaces package, we created three files:</p> <ol> <li>Turtle.msg: Defines the structure of a single turtle.     <pre><code>string name\nfloat32 x\nfloat32 y\nfloat32 theta\n</code></pre></li> <li>TurtleArray.msg: Defines a list of turtles.     <pre><code>Turtle[] turtles\n</code></pre></li> <li>CatchTurtle.srv: A service definition used by the controller to tell the spawner which turtle to remove.     <pre><code>string name\n---\nbool success\n</code></pre> After modifying CMakeLists.txt and package.xml, we compiled the package using colcon build.</li> </ol>"},{"location":"activity04_ros2turtlesim/#4-fisrt-code-turtle-spawner-node","title":"4) Fisrt Code: Turtle Spawner Node","text":"<pre><code>#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nimport random\nimport math\n\nfrom my_robot_interfaces.msg import Turtle, TurtleArray\nfrom turtlesim.srv import Spawn, Kill\nfrom my_robot_interfaces.srv import CatchTurtle\n</code></pre> <ul> <li>Libraries: Imports standard ROS 2 libraries, Python math/random modules, our custom interfaces, and the official Turtlesim services (Spawn and Kill).</li> </ul> <pre><code>class myNode_function(Node):\n    def __init__(self):\n        super().__init__('turtle_spawner')\n        self.alive_turtles_ = []\n        self.publishers_= self.create_publisher(TurtleArray, 'alive_turtles', 10)\n        self.counter = 2\n\n        self.create_timer(1.0, self.publish_turtles)\n\n        self.declare_parameter(\"spawn_frequency\", 1.0) \n        self.frequency_ = self.get_parameter('spawn_frequency').value \n        spawn_period = 1.0 / self.frequency_\n        self.create_timer(spawn_period, self.spawn_turtle)\n\n        self.spawn_ = self.create_client(Spawn, 'spawn')\n        self.kill_ = self.create_client(Kill, 'kill')\n        self.catch_turtles_ = self.create_service(CatchTurtle, 'catch_turtle', self.catch_turtle_callback)\n</code></pre> <ul> <li>Initialization: Initializes an empty list of alive turtles and a publisher. It introduces a ROS 2 Parameter (spawn_frequency) that allows us to change how fast turtles spawn directly from the terminal without changing the code. It also sets up clients to talk to Turtlesim and a Server (catch_turtle) to listen to our Controller.</li> </ul> <pre><code>        def spawn_turtle(self):\n        spawn_request = Spawn.Request() \n        spawn_request.x = random.uniform(0.0, 11.0) \n        spawn_request.y = random.uniform(0.0, 11.0) \n        spawn_request.theta = random.uniform(0.0, 2*math.pi) \n        spawn_request.name = f'turtle{self.counter}' \n        self.counter += 1\n\n        future = self.spawn_.call_async(spawn_request)\n        future.add_done_callback(\n            lambda future_msg: self.spawn_callback(future_msg, spawn_request.x, spawn_request.y, spawn_request.theta)\n        )\n</code></pre> <ul> <li>Spawning Logic: Triggered by the timer, this function generates random coordinates and sends an asynchronous request to Turtlesim to spawn a new turtle. It uses a lambda function to pass the coordinates to the callback once the server responds.</li> </ul> <pre><code>        def catch_turtle_callback(self, request, response):\n        kill_request = Kill.Request()\n        kill_request.name = request.name\n        self.kill_.call_async(kill_request)\n\n        for turtle in self.alive_turtles_:\n            if turtle.name == request.name:\n                self.alive_turtles_.remove(turtle)\n                break\n\n        self.publish_turtles() \n        response.success = True\n        return response\n</code></pre> <ul> <li>Catch Logic: When the Controller node catches a turtle, it calls this service. This function asks Turtlesim to Kill (remove) the turtle from the screen, removes it from our internal alive_turtles_ list, and updates the published array.</li> </ul> <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    parameters_node=myNode_function()\n    rclpy.spin(parameters_node)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n</code></pre> <ul> <li> <p>Main Execution: The main function initializes the ROS2 communication (rclpy.init), creates an instance of the class, and uses rclpy.spin to keep the node running and listening for callbacks until the program is manually stopped. Finally, it shuts down the ROS 2 client library cleanly.</p> </li> <li> <p>Full Code: <pre><code>import rclpy\nfrom rclpy.node import Node\nimport random\nimport math\n\nfrom example_interfaces.msg import String\nfrom my_robot_interfaces.msg import Turtle #custom type msg (name, x, y, and theta)\nfrom my_robot_interfaces.msg import TurtleArray #custom type msg (array of turtles)\n\nfrom turtlesim.srv import Spawn\nfrom turtlesim.srv import Kill\nfrom my_robot_interfaces.srv import CatchTurtle\n\nclass myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('turtle_spawner')    #define the node's name, used for the yaml file\n\n        self.alive_turtles_ = []\n        self.publishers_= self.create_publisher(TurtleArray, 'alive_turtles',10)#crear publisher\n\n        self.counter = 2\n\n        self.get_logger().info('turtle_spawner node is operational')    #confirmation message\n        self.create_timer(1.0, self.publish_turtles) #each second timer\n\n        self.declare_parameter(\"spawn_frequency\", 1.0) #declare a parameter with a default value\n        self.frequency_ = self.get_parameter('spawn_frequency').value #get the parameter value on the variable frequency_\n        spawn_period = 1.0 / self.frequency_\n        self.create_timer(spawn_period, self.spawn_turtle)\n\n        self.spawn_ = self.create_client(Spawn, 'spawn')\n        self.kill_ = self.create_client(Kill, 'kill')\n\n        self.catch_turtles_ = self.create_service(CatchTurtle, 'catch_turtle', self.catch_turtle_callback)#waits for a request in \"catch_turtle\" with structure CatchTurtle and executes the function catch_turtle_callback\n\n\n    def publish_turtles(self):\n        msg = TurtleArray()#msg of type TurtleArray, which contains an array of turtles\n        msg.turtles = self.alive_turtles_#saving the alive turtles in the msg, the list has to be a Turtle type list\n        self.publishers_.publish(msg)\n\n    def spawn_turtle(self):\n        spawn_request = Spawn.Request() #request object for the service (x, y, theta, name)\n        spawn_request.x = random.uniform(0.0, 11.0) #random x\n        spawn_request.y = random.uniform(0.0, 11.0) #random y\n        spawn_request.theta = random.uniform(0.0, 2*math.pi) #random\n        spawn_request.name = f'turtle{self.counter}' #name of the turtle\n        self.counter += 1\n\n        future = self.spawn_.call_async(spawn_request)#call the spawn service with the request, it returns a future object that will contain the response of the service when it is ready\n\n        future.add_done_callback(#when tutlesim service responds, it will execute the spawn_callback function\n            lambda future_msg: self.spawn_callback(future_msg, spawn_request.x, spawn_request.y, spawn_request.theta)#future_msg is the response of the service and the other parameters are the ones we sent in the request, we need them to create the turtle in the spawn_callback function\n        )\n\n    def spawn_callback(self, future_msg, x, y, theta):\n        try:\n            response = future_msg.result()\n            new_turtle = Turtle()\n            new_turtle.name = response.name# /spawn only gives a name\n            new_turtle.x = x\n            new_turtle.y = y\n            new_turtle.theta = theta\n            self.alive_turtles_.append(new_turtle)\n            self.get_logger().info(f'Turtle {response.name} spawned at ({x}, {y}, {theta})')\n        except Exception as e:\n            self.get_logger().error(f'Failed to spawn turtle: {e}')\n\n    def catch_turtle_callback(self, request, response):\n        kill_request = Kill.Request()#request to /kill\n        kill_request.name = request.name#turtle name to kill\n        self.kill_.call_async(kill_request)#send the kill request to the service (kill_ is the client for the /kill service)\n\n        for turtle in self.alive_turtles_:\n            if turtle.name == request.name:\n                self.alive_turtles_.remove(turtle)#delete the turtle from the alive turtles list\n                break\n\n        self.publish_turtles() #publish the updated list of turtles after catching one\n\n        self.get_logger().info(f'Turtle {request.name} caught and removed from alive turtles')\n        response.success = True\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    parameters_node=myNode_function()\n    rclpy.spin(parameters_node)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n</code></pre></p> </li> </ul>"},{"location":"activity04_ros2turtlesim/#5-second-code-turtle-controller-node-pid","title":"5) Second Code: Turtle Controller Node (PID)","text":"<pre><code>import rclpy\nfrom rclpy.node import Node\nimport random\nimport math\n\nfrom example_interfaces.msg import String\nfrom my_robot_interfaces.msg import Turtle\nfrom my_robot_interfaces.msg import TurtleArray\n\nfrom turtlesim.msg import Pose\nfrom geometry_msgs.msg import Twist\n\nfrom my_robot_interfaces.srv import CatchTurtle\n</code></pre> <ul> <li>Libraries: Just like the spawner, we import standard libraries (rclpy, Node, math) and our custom interfaces. The key additions here are Pose from turtlesim.msg (used to get our exact coordinates) and Twist from geometry_msgs.msg (the universal ROS 2 message for commanding linear and angular velocities to move the robot).</li> </ul> <pre><code>class myNode_function(Node):\n    def __init__(self):\n        super().__init__('turtle_controller')\n\n        self.pose = None\n        self.integral_linear = 0.0\n        self.prev_error_linear = 0.0\n\n        self.integral_angular = 0.0\n        self.prev_error_angular = 0.0\n\n        self.current_target_name = \"\" \n\n        self.dt = 0.001 \n\n        self.suscriber_alive_turtles = self.create_subscription(\n            TurtleArray,'alive_turtles',self.alive_turtles_callback,10) \n\n        self.suscriber_pose = self.create_subscription(\n            Pose,'turtle1/pose',self.pose_callback,10) \n\n        self.alive_turtles_ = []\n\n        self.publishers_= self.create_publisher(Twist, 'turtle1/cmd_vel',10)\n\n        self.catch_ = self.create_client(CatchTurtle, 'catch_turtle')\n\n        self.create_timer(0.001, self.control_turtles)\n\n        self.get_logger().info('turtle_controller node is operational')\n</code></pre> <ul> <li>Node Initialization: The node is named \"turtle_controller\". We initialize self.pose = None to avoid crashing before the first GPS message arrives. We declare variables to store the PID controller memory: integrals (accumulated error) and previous errors, for both linear and angular movements. self.dt = 0.001 represents the time differential. We create two Subscribers (for the alive turtles list and our own pose), one Publisher for the Twist commands, and a Client for the CatchTurtle service. Finally, a fast timer (0.001s) is created to run the control loop.</li> </ul> <pre><code>        def alive_turtles_callback(self, msg: TurtleArray):\n        self.alive_turtles_ = msg.turtles\n\n    def pose_callback(self, msg: Pose):\n        self.pose = msg\n</code></pre> <ul> <li>Subscriber Callbacks: Every time the Spawner publishes the array of targets, alive_turtles_callback updates our internal list. Every time the simulator publishes the hunter's coordinates, pose_callback saves the data into self.pose.</li> </ul> <pre><code>        def control_turtles(self):\n        if self.pose is None or len(self.alive_turtles_) == 0:\n            return \n        closest_turtle = None\n        closest_distance = 1000.0\n\n        for turtle in self.alive_turtles_:\n            dist_x = turtle.x - self.pose.x\n            dist_y = turtle.y - self.pose.y\n            distance = math.sqrt(dist_x**2 + dist_y**2)\n\n            if distance &lt; closest_distance:\n                closest_distance = distance\n                closest_turtle = turtle\n\n        if closest_turtle is None:\n            self.get_logger().info(\"No closest turtle found.\")\n            return\n\n        if closest_turtle.name != self.current_target_name:\n            self.integral_linear = 0.0\n            self.prev_error_linear = 0.0\n            self.integral_angular = 0.0\n            self.prev_error_angular = 0.0\n            self.current_target_name = closest_turtle.name\n</code></pre> <ul> <li>Target Lock: This part of the control loop ensures we have data. Then, it uses the Pythagorean theorem to calculate the distance to all alive turtles and selects the closest one. If the closest turtle is different from our current target, we will change the current target. To avoid erratic movements from old PID memory, it resets the integrals and derivatives to 0.0 and saves the new target's name.</li> </ul> <pre><code>        if closest_distance &lt; 0.5:\n            msg = Twist()\n            msg.linear.x = 0.0\n            msg.angular.z = 0.0\n            self.publishers_.publish(msg)\n\n            request = CatchTurtle.Request()\n            request.name = closest_turtle.name\n            self.catch_.call_async(request)\n            return\n</code></pre> <ul> <li>Catch Condition: If the distance to the target is less than 0.5 units, the robot considers it caught. It immediately publishes a Twist message with 0.0 velocities to stop the hunter. It then prepares a CatchTurtle request with the prey's name and sends it to the Spawner node asynchronously. The function returns early to stop the PID calculations for this cycle.</li> </ul> <pre><code>        msg = Twist()\n\n        target_angle = math.atan2(closest_turtle.y - self.pose.y, closest_turtle.x - self.pose.x)\n        error_angular = target_angle - self.pose.theta\n\n        if error_angular &gt; math.pi:\n            error_angular -= 2 * math.pi\n        elif error_angular &lt; -math.pi:\n            error_angular += 2 * math.pi\n\n        self.integral_angular += error_angular * self.dt \n        derivative_angular = (error_angular - self.prev_error_angular) / self.dt \n\n        Kp_angular = 2.0\n        Ki_angular = 0.1\n        Kd_angular = 0.5\n\n        msg.angular.z = Kp_angular * error_angular + Ki_angular * self.integral_angular + Kd_angular * derivative_angular\n        self.prev_error_angular = error_angular\n\n        error_linear = closest_distance\n        self.integral_linear += error_linear * self.dt\n        derivative_linear = (error_linear - self.prev_error_linear) / self.dt \n\n        Kp_linear = 1.0\n        Ki_linear = 0.1\n        Kd_linear = 0.5\n\n        msg.linear.x = Kp_linear * error_linear + Ki_linear * self.integral_linear + Kd_linear * derivative_linear\n        self.prev_error_linear = error_linear\n\n        self.publishers_.publish(msg)\n</code></pre> <ul> <li>PID Controller: </li> <li>Angular (Steering): It uses atan2 to find the desired angle and calculates the error. It standardizes the error between -\u03c0 and \u03c0 to take the shortest path. It applies numerical integration (multiplying error by dt) and derivation (rate of change over dt). It applies the Gains (Kp, Ki, Kd) and assigns the result to the angular velocity (msg.angular.z).</li> <li> <p>Linear (Accelerator): The error is simply the distance. It calculates its integral and derivative (the braking effect before a crash). It applies its respective Gains and assigns the result to the linear velocity (msg.linear.x). Finally, it publishes the movement. <pre><code>def main(args=None):\n    rclpy.init(args=args)\n    parameters_node=myNode_function()\n    rclpy.spin(parameters_node)   \n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre></p> </li> <li> <p>Main Execution: The main function initializes ROS 2, creates the node object, and spins it to keep the 0.001s control loop timer active. This ensures the PID controller evaluates the math continuously until the user stops the program.</p> </li> <li> <p>Full Code: <pre><code>import rclpy\nfrom rclpy.node import Node\nimport random\nimport math\n\nfrom example_interfaces.msg import String\nfrom my_robot_interfaces.msg import Turtle #custom type msg (name, x, y, and theta)\nfrom my_robot_interfaces.msg import TurtleArray #custom type msg (array of turtles)\n\nfrom turtlesim.msg import Pose\nfrom geometry_msgs.msg import Twist\n\nfrom my_robot_interfaces.srv import CatchTurtle\n\nclass myNode_function(Node):\n\n    def __init__(self):\n        super().__init__('turtle_controller')    #define the node's name, used for the yaml file\n\n        self.pose = None\n        self.integral_linear = 0.0\n        self.prev_error_linear = 0.0\n\n        self.integral_angular = 0.0\n        self.prev_error_angular = 0.0\n\n        self.current_target_name = \"\" #for saving the name of the turtle we are trying to catch, so we don't change the target until we catch it or it disappears\n\n        self.dt = 0.001 #our control loop runs every 0.01 seconds, so dt is 0.01 for the PID controller\n\n        self.suscriber_alive_turtles = self.create_subscription(\n            TurtleArray,'alive_turtles',self.alive_turtles_callback,10) #create subscriber to alive_turtles\n\n        self.suscriber_pose = self.create_subscription(\n            Pose,'turtle1/pose',self.pose_callback,10) #create subscriber to turtle_pose\n\n        self.alive_turtles_ = []\n\n        self.publishers_= self.create_publisher(Twist, 'turtle1/cmd_vel',10)#crear publisher\n\n        self.catch_ = self.create_client(CatchTurtle, 'catch_turtle')#client for the catch_turtle service, we will use it to catch turtles from this node\n\n        self.create_timer(0.001, self.control_turtles)\n\n        self.get_logger().info('turtle_controller node is operational')#confirmation message\n\n\n    def alive_turtles_callback(self, msg: TurtleArray):\n        self.alive_turtles_ = msg.turtles\n\n    def pose_callback(self, msg: Pose):\n        self.pose = msg\n\n    def control_turtles(self):\n        if self.pose is None or len(self.alive_turtles_) == 0:#if we don't have the pose of our turtle or there are no alive turtles, return and do nothing\n            return \n        closest_turtle = None\n        closest_distance = 1000.0#a huge number\n\n        for turtle in self.alive_turtles_:\n            #Calculate the distance from our turtle to each alive turtle\n            dist_x = turtle.x - self.pose.x\n            dist_y = turtle.y - self.pose.y\n            distance = math.sqrt(dist_x**2 + dist_y**2)\n\n            if distance &lt; closest_distance:\n                closest_distance = distance\n                closest_turtle = turtle\n\n        if closest_turtle is None:\n            self.get_logger().info(\"No closest turtle found.\")\n            return\n\n        if closest_turtle.name != self.current_target_name:#if the closest turtle is different, we creset the PID. Current target starts as an empty string, so the if will enter in the first iteration\n            self.integral_linear = 0.0\n            self.prev_error_linear = 0.0\n            self.integral_angular = 0.0\n            self.prev_error_angular = 0.0\n            self.current_target_name = closest_turtle.name\n\n        if closest_distance &lt; 0.5:#if the closest turtle is less than 0.5 units away, we catch it\n            msg = Twist()#msg of type Twist, which contains linear and angular velocities\n            msg.linear.x = 0.0\n            msg.angular.z = 0.0\n            self.publishers_.publish(msg)\n\n            request = CatchTurtle.Request()\n            request.name = closest_turtle.name\n            self.catch_.call_async(request)\n            return\n\n        msg = Twist()\n\n        target_angle = math.atan2(closest_turtle.y - self.pose.y, closest_turtle.x - self.pose.x)#angle to the target turtle\n        error_angular = target_angle - self.pose.theta#error between the angle to the target and our turtle's angle\n\n        if error_angular &gt; math.pi:#standardize the error to be between -pi and pi, so we take the shortest path\n            error_angular -= 2 * math.pi\n        elif error_angular &lt; -math.pi:\n            error_angular += 2 * math.pi\n\n        self.integral_angular += error_angular * self.dt #numeric method for the integral (thanks Oscar Fountains)\n        derivative_angular = (error_angular - self.prev_error_angular) / self.dt #the speed at which the error is changing. Numeric method for the derivative (thanks Oscar Fountains)\n\n        Kp_angular = 2.0\n        Ki_angular = 0.1\n        Kd_angular = 0.5\n\n        msg.angular.z = Kp_angular * error_angular + Ki_angular * self.integral_angular + Kd_angular * derivative_angular#angular msg of twist\n        self.prev_error_angular = error_angular#save the error for the next iteration\n\n        error_linear = closest_distance#the error for the linear velocity is the distance to the target\n        self.integral_linear += error_linear * self.dt#the distance error integrated over time, it increases when we are far from the target and decreases when we are close\n        derivative_linear = (error_linear - self.prev_error_linear) / self.dt #the speed at which the distance error is changing\n\n        Kp_linear = 1.0\n        Ki_linear = 0.1\n        Kd_linear = 0.5\n\n        msg.linear.x = Kp_linear * error_linear + Ki_linear * self.integral_linear + Kd_linear * derivative_linear#linear msg of twist\n        self.prev_error_linear = error_linear#save the error for the next iteration\n\n        self.publishers_.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    parameters_node=myNode_function()\n    rclpy.spin(parameters_node)   #keeps going a program until someone stop it\n    rclpy.shutdown()\n</code></pre></p> </li> </ul>"},{"location":"activity04_ros2turtlesim/#6-bringup-package-launch-params","title":"6) Bringup Package (Launch + Params)","text":"<p>To run our entire ecosystem (the simulator, the spawner, and the controller) with a single command, we used an XML launch file and a CMake build type.</p> <p>We created a new package named \"myrobot_bringup\" and structured it with a \"config\" folder for our parameters and a \"launch\" folder for our XML launch file.</p> <ul> <li>Inside \"myrobot_bringup/config/rob_param.yaml\", we defined the parameters we want into our nodes. In this case, we set the spawn frequency for our \"turtle_spawner\".</li> </ul> <p><pre><code>turtle_spawner:\n  ros__parameters:\n    spawn_frequency: 1.0\n</code></pre> - Explanation: The YAML file uses the exact name of the node (\"turtle_spawner\"), followed by the \"ros__parameters\" keyword. Underneath, we define our custom \"spawn_frequency\" variable and set it to 1.0.</p> <ul> <li>Inside \"myrobot_bringup/launch/app_launch.xml\", we wrote an XML script to control the startup of all three nodes and load the YAML file.</li> </ul> <p><pre><code>&lt;launch&gt;\n    &lt;node pkg=\"turtlesim\" exec=\"turtlesim_node\" name=\"turtlesim\" /&gt;\n\n    &lt;node pkg=\"turtle\" exec=\"turtle_spawner\" name=\"turtle_spawner\"&gt;\n        &lt;param from=\"$(find-pkg-share myrobot_bringup)/config/rob_param.yaml\" /&gt;\n    &lt;/node&gt;\n\n    &lt;node pkg=\"turtle\" exec=\"turtle_controller\" name=\"turtle_controller\" /&gt;\n&lt;/launch&gt;\n</code></pre> - <code>&lt;launch&gt;</code>: The root tag that defines this as a ROS 2 launch file. - <code>&lt;node&gt;</code>: This tag starts a specific node. We specify the package (\"pkg\"), the executable name (\"exec\"), and the node name (\"name\"). - <code>&lt;param from=\"...\" /&gt;</code>: Inside the spawner node block, we use this tag to dynamically locate the \"myrobot_bringup\" package and inject the \"rob_param.yaml\" configuration into the node at runtime.</p> <ul> <li>Because \"myrobot_bringup\" is a CMake package, we needed to instruct the compiler to install our \"launch\" and \"config\" folders into the ROS 2 share directory so they can be found during execution. We added this snippet to \"CMakeLists.txt\" right before \"ament_package()\":</li> </ul> <pre><code>install(DIRECTORY\n  launch\n  config\n  DESTINATION share/${PROJECT_NAME}\n)\n</code></pre> <ul> <li>After building the workspace (\"colcon build\"), the entire project\u2014with the adjusted 3.0 spawn rate\u2014can be booted up simultaneously using a single terminal command:</li> </ul> <pre><code>ros2 launch myrobot_bringup app_launch.xml\n</code></pre>"},{"location":"activity04_ros2turtlesim/#7-results","title":"7) Results","text":""},{"location":"activity04_ros2turtlesim/#8-conclusions","title":"8) Conclusions","text":"<ul> <li>General: We built a fully autonomous system, a very big challenge for our programming skills. We learned how to manage robot states dynamically and applied real-world Calculus to solve robotic problems through a PID Controller. The resulting movement is optimized, and independent of processor speed thanks to the proper use of the time differential (dt) in our mathematical integrations.</li> </ul>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"examplesofrobots/","title":"\ud83d\udcda Examples Of Robots By Morphology","text":"<p>In this assigment I looked for different applications of the robots reviewed on class</p>"},{"location":"examplesofrobots/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: Examples Of Robots By Morphology  </li> <li>Author: Angel Ivan Dominguez Cruz </li> <li>Subject: Applied Robotics</li> <li>Date: 27/01/2026 </li> </ul>"},{"location":"examplesofrobots/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: Analyze and compare different industrial robot morphologies by examining thir kinematic structures, degrees of freedom and resulting workspaces.</li> </ul>"},{"location":"examplesofrobots/#3-robots-by-morphologies","title":"3) Robots By Morphologies","text":"<ul> <li>Catesian Robot: These robots operate on three axes (X, Y and Z) at 90 degree angles to each other. This structure allows the to cover a rectangular or cubical workspace. An example could be the TPA-E Series Gantry Robot from Macron Dynamics. These robots are used for automated material handling (carrying heavy things) or assembling large components.</li> </ul> <ul> <li>Cylindrical Robot: These robots have a rotary base, a vertical linear axis and a horizontal linear axis. These robots create a cylindrical workspace. A real life example is the Seiko D-TRAN RT3300. These type of robots are less common today, but they are used for simple pick and place operations, machine tending and assembly tasks.</li> </ul> <ul> <li>Polar Robot: These robots have a rotary base, a rotary shoulder joint and a linear axis to extend and retract the arm. The workspace of these robots is a sphere. The Unimate (the first industrial robot) is the most famous example and it was used by General Motors in the 1960s for spot welding and die-casting.</li> </ul> <ul> <li>Jointed-Arm Robot: This is the most common type of industrial robot today. It features a series of rotary joints that emulates the structure of a human arm, providing an exceptional flexibility and a large and complex workspace. A great example could be de FANUC R-2000iC series. This robot is an articulated leading robot used in tasks like arc welding on automotive assembly lines, painting car bodies, handling materials, and performing complex assembly operations.</li> </ul> <ul> <li>SCARA Robot: SCARA stans for Selective Compliance Assembly Robot Arm. It has two parallel rotary joints that allow it to move quickly in the X-Y plane and a linear axis for Z-plane motion. My example is the Epson G-Series SCARA robots that are widely used in electronics industry for high-speed, precision assembly. Their speed and accuracy make them perfect for tasks like inserting components into printed circuit boards, sorting small parts, and packaging products where fast pick and place cycles are essential.</li> </ul> <ul> <li>DELTA Robot: Is a type of parallel robot, recognized by its three arms connected to a single base above the workspace. This design, often using lightweight carbon fiber materials, allows for extremely fast and precise movements within a dome-shaped workspace. The ABB IRB 360 FlexPicker is the most famous Delta robot in the world. It is a leader in speed picking and packing technology. Its incredible speed and acceleration make it perfect for tasks like sorting candies, packaging medical devices, and assembling small electronic parts directly on a conveyor belt.</li> </ul>"},{"location":"fkmatrix/","title":"\ud83d\udcda Forward Kinematics","text":"<p>In this assigment I solved different Forward Kinematics problems.</p>"},{"location":"fkmatrix/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: Forward Kinematics</li> <li>Author: Angel Ivan Dominguez Cruz </li> <li>Subject: Applied Robotics</li> <li>Date: 05/02/2026 </li> </ul>"},{"location":"fkmatrix/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: To analyze different robotic mechanisms by applying forward kinematics techniques, using Denavit\u2013Hartenberg (DH) parameters and homogeneous transformation matrices to determine the position and orientation of the end-effector.</li> </ul>"},{"location":"fkmatrix/#3-first-excercise","title":"3) First Excercise","text":"<ul> <li>Explanation: This exercise focuses on a simple articulated mechanism with rotational and prismatic components. The objective is to assign coordinate frames, define the DH parameters, and compute the transformation matrix to obtain the end-effector pose.</li> </ul>"},{"location":"fkmatrix/#4-second-excercise","title":"4) Second Excercise","text":"<ul> <li>Explanation: This exercise presents a robot with multiple prismatic joints arranged in different directions. The goal is to analyze linear displacements and combine them using homogeneous transformations.</li> </ul>"},{"location":"fkmatrix/#5-third-excercise","title":"5) Third Excercise","text":"<ul> <li>Explanation: This exercise involves a multi-joint robotic arm with several rotational axes. The task is to model a serial manipulator and determine its full kinematic chain.</li> </ul>"},{"location":"fkmatrix/#6-fourth-excercise","title":"6) Fourth Excercise","text":"<ul> <li>Explanation: This exercise represents an industrial-type robotic arm with defined link lengths and joint rotation limits. The objective is to apply the DH convention to a realistic robot model and compute its workspace configuration.</li> </ul>"},{"location":"fkmatrix/#7-fifth-excercise","title":"7) Fifth Excercise","text":"<ul> <li>Explanation: This exercise focuses on a complex industrial robot with multiple degrees of freedom and a defined working envelope. The task is to determine the forward kinematics and analyze the reachable workspace.</li> </ul>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"hw2_nomenclature/","title":"\ud83d\udcda Transform Nomenclature","text":"<p>In this assigment I solved different Translation and Rotation axis problems.</p>"},{"location":"hw2_nomenclature/#1-summary","title":"1) Summary","text":"<ul> <li>Homework Name: Transform Nomenclature </li> <li>Author: Angel Ivan Dominguez Cruz </li> <li>Subject: Applied Robotics</li> <li>Date: 29/01/2026 </li> </ul>"},{"location":"hw2_nomenclature/#2-objectives","title":"2) Objectives","text":"<ul> <li>General: To develop the ability to solve problems involving rotation and transformation of vectors and coordinate systems by formulating the appropriate rotation and homogeneous transformation matrices, and understanding the relationship between different reference frames through these transformations.</li> </ul>"},{"location":"hw2_nomenclature/#3-first-excercise","title":"3) First Excercise","text":"<ul> <li>Explanation: In this exercise, the objective is to rotate a vector named P about two different axes. First, the vector is rotated around the Y axis of frame A by an angle of forty five degrees. Then, it is rotated around the X axis of frame A by an angle of sixty degrees. The goal is to determine the rotation matrix that performs both rotations in the specified order.</li> </ul>"},{"location":"hw2_nomenclature/#4-second-excercise","title":"4) Second Excercise","text":"<ul> <li>Explanation: This exercise involves both rotation and translation between coordinate frames. The reference frame B is rotated with respect to reference frame A around the X axis of frame A by thirty degrees. In addition, the translation of frame B relative to frame A is given by a vector with components five and ten.</li> </ul>"},{"location":"hw2_nomenclature/#5-third-excercise","title":"5) Third Excercise","text":"<ul> <li>Explanation: In this exercise, the task is to analyze the given image to obtain the transformation matrices between different reference frames. Specifically, the transformations from frame A to frame B and from frame A to frame C.</li> </ul>"}]}